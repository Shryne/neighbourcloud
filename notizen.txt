Repository Klasse:
dient der Abstraktion der Speicherung, Suche von den (Fach)Objekten in der Geschäftslogikschicht.
Bietet Zugriffsmechanismen auf die Infrastruktur (z. B. Datenbank). Nur hier wird mit der Datenbank kommuniziert.
 - stellt Funktionen zum Anlegen, Löschen, Lesen, Ändern zur Verfügung
 - DAO Pattern (Data Access Object) -> Kapselt Zugriff auf Datenquelle (FS, DB) so, dass die darunterliegende Quelle ausgetauscht werden kann
 - minimiert Portierungsaufwand

Entitäts Klasse:
Objekte die durch ihre Identität definiert werden und nicht durch ihre Eigenschaften (->Datentyp). Bsp. Person
  eine Person bleibt die selbe Person auch wenn sich ihre Eigenschaften Ändern, zwei Personen mit den gleichen Eigenschaften sind trotzdem nicht identisch.

Use Case Klasse:
Use Case beschreibt Schritte wenn ein Akteur mit Hilfe unseres Softwaresystems ein bestimmtes Ziel erreichen möchte.
Dadurch ergeben sicher Operationen die Entweder als Geschäfts- oder als Systemoperation anzusehen sind.

Geschäftsoperationen werden in Use Case Klassen implementiert
 - entitätsübergreifende Funktionalität
 - Fachlogik
 - verwenden Repository Klassen
Bsp. ueberweise()

Systemoperationen:
ergeben sich aus den Use Cases. systemunterstützte Teile des Use Case werdne als Systemoperation implementiert:
Bsp. Logout, storniereBuchung, login, druckeBestellübersicht 

Spring Boot
allgemein zu Spring: Idee -> Dependeny Injection
Benötigt ein Objekt bei der Initialisierung ein anderes Objekt wir dieses andere Objekt von Spring erzeugt und nicht im Objekt selbst.
Dadurch trennt man DB von der Geschäftslogik
bsp. ist folgender nicht nötig mittels Spring: User neuerUser = new UserFromDB();
Problem hierbei: Wenn ich in Zukunft keine Datenbank mehr verwenden möchte sondern ein CSV einlesen möchte habe ich ein Prob.

Spring ist allerdings recht kompliziert zu konfigurieren (mittels XML Files)
Spring Boot ist ein einfacher Ansatz von Spring:
macht vieles automatisch; Konfiguration mittels Annotationen; kein XML Konfig notwendig

Spring Data JPA:
JPA (Java Persistence API) -> Schnittstelle um Laufzeitobjekte persistent zu Speichern (auf Basis einer relationalen Datenbank)
Spring Data JPA versucht dies einfacher zu gestalten. (da Datenbank -> in Repository Klassen relevant)
Spring übernimmt hier das konkrete implementieren von Standard DB Funktionen z.B. create().
Dazu Verwendet Sprign Data JPA das Framework Hibernate

Hibernate:
Aufgabe: objekt relationale Abbildung (ORM)
Java Objekte mit Attributen und Methoden sollen in rel. DB gespeichert werden und umgekehrt aus Datensätzen der DB wiederum Objekte erzeugt werden.
 - versteht mehrere SQL Dialekte
 - ist in Spring integriert

Buildsystem
Idee der automatisierten Erzeugung des Programms
 - Abhängigkeiten lösen, Linken und compilen, Tests ausführen, Code Qualität prüfen (unternehmens coding standard), etc.
 - lokale Sourcen, Internet, Frameworks etc. und andere Abhängigkeiten können automatisiert verarbeitet werden
 - möglich: Build Server -> ständiges Bauen des gesamten Projektes zeigt Fehler frühzeitig
 - möglich: verteilter Build

Grade - Buildsystem speziell für Javaprojekte
 - im Vergleich zu Maven sind Gradle Skripte direkte ausführbar und nicht .xml
 - Konvention vor Konfiguration -> Sinnvolle Annahmen erleichtern das Arbeiten
 - zwei Phasen: config + build
 - compiliert nur wenn nötig (falls keine neuen Änderungen in Modul X wird dieses nicht erneut gebaut)

SoC
Separation-of-Concerns
nix Mischen von fachlich und technisch
--> führt zu einem modularen Programm und unseren Schichten...
--> Programmteile können mehrfach wiederverwendet werden, unabhängig von anderen Teilen optimiert werden, unabhängig vom Versagen andere Funktionen...

Bsp: Internet Protokoll Stack: IP,TCP
     Web: HTML, CSS, JavaScript

Referenzarchitektur:
beschreibt den Aufbau von Softwaresystemen im Großen:
idealtypisches Modell für eine Klasse von zu modelierender Architekturen -> Schablone
bsp. Data-Warehouser, Internet of Things für die Industrie
 - baut auf bewährtem auf (System muss nicht von Null auf entwickelt werdne)
 - best practices
 
Schichten-Architektur
GUI - Geschäftslogik - Persistenzschicht
